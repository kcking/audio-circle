<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <script src="//code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="/angular.js"></script>
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet" type="text/css">
    <script>
      var bufferSize = 1024;
      var convolutionWindow = 64;
      var chirpFrequency = 10000;
      var chirpLength = 4 * 44.1;

      var state, chirpLatency, sample, lastChirpTime, nextChirpTime;
      var context, soundSource, microphone, convolver, processor, prevInputBuffer; // global because of Chrome bugs
      state = 'init';
      sample = 0;
      chirpLatency = 0;
      nextChirpTime = null;

      var numSelfChirpsLeft = 3;
      var expectedSelfChirpTime;
      var selfChirpTimer = null;
      var selfChirpEstimates = [];

      function selfChirp() {
        if (selfChirpTimer !== null) {
          clearTimeout(selfChirpTimer);
        }
        expectedSelfChirpTime = sample + chirpLength * 100;
        chirp(expectedSelfChirpTime);
        state = 'determine-own-latency';
        selfChirpTimer = setTimeout(function() {
          selfChirp();
        }, 2000);
      }

      var rttInitTimeA, syncTime;
      var numSyncTimesLeft = 3;
      var syncTimes = [];

      function initiateA() {
        console.log('initiateA');
        if (numSyncTimesLeft === 0) {
          syncTimes.sort();
          syncTime = syncTimes[Math.floor(syncTimes.length / 2)];
          console.log(syncTimes);
          state = 'dead-a';
        } else {
          rttInitTimeA = sample + chirpLatency * 2;
          chirp(rttInitTimeA);
          state = 'rtt-wait-own-a';
          numSyncTimesLeft--;
        }
      }

      function initiateB() {
        console.log('initiateB');
        if (numSyncTimesLeft === 0) {
          syncTimes.sort();
          syncTime = syncTimes[Math.floor(syncTimes.length / 2)];
          console.log(syncTimes);
          state = 'dead-b';
        } else {
          state = 'rtt-wait-other-b';
          numSyncTimesLeft--;
        }
      }

      function nodeA() {
        if (state === 'rtt-init') {
          initiateA();
        } else {
          alert('Not ready yet.');
        }
      };

      function nodeB() {
        if (state === 'rtt-init') {
          initiateB();
        } else {
          alert('Not ready yet.');
        }
      };

      function chirp(time) {
        nextChirpTime = time - chirpLatency;
      }

      function onChirp() {
        if (state === 'determine-own-latency') {
          selfChirpEstimates.push(sample - expectedSelfChirpTime);
          numSelfChirpsLeft--;
          if (numSelfChirpsLeft == 0) {
            selfChirpEstimates.sort();
            chirpLatency = selfChirpEstimates[Math.floor(selfChirpEstimates.length / 2)];
            clearTimeout(selfChirpTimer);
            state = 'rtt-init';
          } else {
            selfChirp();
          }
        } else if (state === 'rtt-wait-own-a') {
          state = 'rtt-wait-other-a';
        } else if (state === 'rtt-wait-other-a') {
          syncTimes.push(rttInitTimeA + Math.round((sample - rttInitTimeA) / 2));
          state = 'limbo';
          setTimeout(initiateA, 1000);
        } else if (state === 'rtt-wait-other-b') {
          syncTimes.push(sample + 10 * chirpLatency);
          chirp(sample + 20 * chirpLatency);
          state = 'rtt-wait-own-b';
        } else if (state === 'rtt-wait-own-b') {
          initiateB();
        } else if (state === 'dead-b') {
          var last = (syncTime % 44100) + Math.floor((sample + chirpLatency * 2) / 44100) * 44100;
          console.log(String((sample - last) / 44100 * 340.29) + 'm');
        }
      }

      // initialize audio
      function initAudio() {
        navigator.getUserMedia  = navigator.getUserMedia ||
                                  navigator.webkitGetUserMedia ||
                                  navigator.mozGetUserMedia ||
                                  navigator.msGetUserMedia;
        window.AudioContext     = window.AudioContext ||
                                  window.webkitAudioContext;
        if (navigator.getUserMedia && window.AudioContext) {
          navigator.getUserMedia({ audio: true }, function(stream) {
            context = new AudioContext();

            var inChirp = false;
            lastChirpTime = null;

            processor = context.createScriptProcessor(bufferSize, 1, 1);
            prevInputBuffer = context.createBuffer(1, bufferSize, 44100);
            sample = 0;
            processor.onaudioprocess = function(e) {
              var inputData = e.inputBuffer.getChannelData(0);
              var outputData = e.outputBuffer.getChannelData(0);
              var prevData = prevInputBuffer.getChannelData(0);
              var sampleToRadians = chirpFrequency * 2 * Math.PI / 44100;
              for (var i = 0; i < bufferSize; i++) {
                var sinComponent = 0;
                var cosComponent = 0;
                var rmsSquared = 0;
                for (var j = 0; j < convolutionWindow; j++) {
                  var arg = (sample - j) * sampleToRadians;
                  var s;
                  if (i < j) {
                    s = prevData[bufferSize + i - j];
                  } else {
                    s = inputData[i - j];
                  }
                  sinComponent += s * Math.sin(arg);
                  cosComponent += s * Math.cos(arg);
                  rmsSquared += s * s;
                }
                rmsSquared /= convolutionWindow;
                var result = ((sinComponent * sinComponent / rmsSquared) + (cosComponent * cosComponent / rmsSquared)) / (convolutionWindow * convolutionWindow);
                if (result > 0.3025) {
                  if (!inChirp && (lastChirpTime === null || sample - lastChirpTime > chirpLength * 50)) {
                    onChirp();
                    lastChirpTime = sample;
                    inChirp = true;
                  }
                } else if (result < 0.09 && inChirp) {
                  inChirp = false;
                }

                if (nextChirpTime && sample > nextChirpTime && sample < nextChirpTime + chirpLength) {
                  outputData[i] = Math.sin(sample * sampleToRadians);
                } else {
                  outputData[i] = 0;
                }

                sample++;
              }
              for (var i = bufferSize + 1 - convolutionWindow; i < bufferSize; i++) {
                prevData[i] = inputData[i];
              }
            }
            processor.connect(context.destination);

            microphone = context.createMediaStreamSource(stream);
            microphone.connect(processor);

            selfChirp();
          }, function(e) {
            alert('Error calling getUserMedia: ' + String(e));
            state = 'super-dead';
          });
        } else {
          alert('Unsupported browser.');
          state = 'super-dead';
        }
      }

      setInterval(function() {
        if (state === 'dead-a') {
          if (sample > nextChirpTime + chirpLength) {
            chirp((syncTime % 44100) + Math.ceil((sample + chirpLatency * 2) / 44100) * 44100);
          }
        }
      }, 1);

      $(initAudio);
    </script>
  </head>
  <body>
    <button type="button" onclick="nodeA();">Node A</button>
    <button type="button" onclick="nodeB();">Node B</button>
  </body>
</html>